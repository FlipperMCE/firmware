; largely based on https://github.com/dangiu/PicoMemcard/blob/pmc%2B/release/psxSPI.pio

; INJECTION (${VARIANT})
.define PUBLIC PIN_GC_INT ${PIN_GC_INT}
.define PUBLIC PIN_GC_SEL ${PIN_GC_SEL}
.define PUBLIC PIN_GC_CLK ${PIN_GC_CLK}
.define PUBLIC PIN_GC_DI ${PIN_GC_DI}
.define PUBLIC PIN_GC_DO ${PIN_GC_DO}

; SD2PSX
;.define PUBLIC PIN_GC_INT 16
;.define PUBLIC PIN_GC_SEL 17
;.define PUBLIC PIN_GC_CLK 18
;.define PUBLIC PIN_GC_DI 19
;.define PUBLIC PIN_GC_DO 20
;.define PUBLIC PIN_GC_SPD_SEL 10

; BitFunX (?)
;.define PUBLIC PIN_GC_INT 9
;.define PUBLIC PIN_GC_SEL 7
;.define PUBLIC PIN_GC_CLK 8
;.define PUBLIC PIN_GC_DI 6
;.define PUBLIC PIN_GC_DO 5
;.define PUBLIC PIN_GC_SPD_SEL 25

.program cmd_reader
.wrap_target
    wait 0 gpio PIN_GC_SEL  ; wait for SEL
    wait 1 gpio PIN_GC_CLK  ; wait for rising clock edge
    in pins 1                ; sample 1 bit from the CMD line
    wait 0 gpio PIN_GC_CLK  ; wait for clock to fall
.wrap

.program dat_writer
    wait 0 gpio PIN_GC_SEL           ; wait for initial chip select
    set pins  1                       ; configure DAT pin for output
.wrap_target
    jmp !osre start
    pull block                        ; get first byte ready
    wait 1 irq 6                      ; wait for clock program to end of last byte
    wait 0 gpio PIN_GC_CLK            ; wait for falling edge

start:
    out pins, 1                       ; output next bit
bit_loop:
    wait 1 gpio PIN_GC_CLK
    out pins, 1                       ; output next bit
    wait 0 gpio PIN_GC_CLK
    jmp !osre bit_loop
;    jmp !osre bit_loop
;    jmp x-- bit_loop                  ; continue until byte complete
;    out pins, 1                       ; output next bit
;    set x, 6
;    wait 1 gpio PIN_GC_CLK
;    wait 0 gpio PIN_GC_CLK
.wrap                                 ; get next byte

.program clock_probe
    wait 0 gpio PIN_GC_SEL           ; wait for chip select
    irq set 6                         ; signal start of byte
.wrap_target
    set x, 6                          ; count 7 bits (6 down to 0)
    wait 0 gpio PIN_GC_CLK           ; wait for falling edge

bit_wait:
    wait 1 gpio PIN_GC_CLK           ; wait for rising edge
    irq clear 6
    wait 0 gpio PIN_GC_CLK           ; wait for falling edge
    jmp x-- bit_wait                  ; continue for all 8 bits
    wait 1 gpio PIN_GC_CLK           ; wait for rising edge
    irq set 6
.wrap                                 ; wrap for next byte

% c-sdk {

static inline void cmd_reader_program_init(PIO pio, uint sm, uint offset) {
    pio_sm_config c = cmd_reader_program_get_default_config(offset);

    sm_config_set_in_pins(&c, PIN_GC_DI);
    pio_sm_set_consecutive_pindirs(pio, sm, PIN_GC_DI, 1, false);
    pio_sm_set_consecutive_pindirs(pio, sm, PIN_GC_SEL, 1, false);
    pio_sm_set_consecutive_pindirs(pio, sm, PIN_GC_CLK, 1, false);

    /* shift ISR to right, autopush every 8 bits */
    sm_config_set_in_shift(&c, false, true, 8);
    sm_config_set_fifo_join(&c, PIO_FIFO_JOIN_RX);

    pio_sm_init(pio, sm, offset, &c);
}

static inline void dat_writer_program_init(PIO pio, uint sm, uint offset) {
    pio_sm_config c = dat_writer_program_get_default_config(offset);

    sm_config_set_out_pins(&c, PIN_GC_DO, 1);
    sm_config_set_set_pins(&c, PIN_GC_DO, 1);


    /* configure DAT pin for output */
    pio_sm_set_pins_with_mask(pio, sm, 1 << PIN_GC_DO, 1 << PIN_GC_DO);
    pio_sm_set_consecutive_pindirs(pio, sm, PIN_GC_DO, 1, true);
    pio_gpio_init(pio, PIN_GC_DO);

    /* SEL and CLK used as "wait" inputs only */
    pio_sm_set_consecutive_pindirs(pio, sm, PIN_GC_SEL, 1, false);
    pio_sm_set_consecutive_pindirs(pio, sm, PIN_GC_CLK, 1, false);

    /* shift OSR to right, autopull every 8 bits */
    sm_config_set_out_shift(&c, false, true, 8);
    sm_config_set_fifo_join(&c, PIO_FIFO_JOIN_TX);

    pio_sm_init(pio, sm, offset, &c);
}


static inline void clock_probe_program_init(PIO pio, uint sm, uint offset) {
    pio_sm_config c = clock_probe_program_get_default_config(offset);

    pio_sm_set_consecutive_pindirs(pio, sm, PIN_GC_SEL, 1, false);
    pio_sm_set_consecutive_pindirs(pio, sm, PIN_GC_CLK, 1, false);


    /* shift ISR to right, autopush every bit */
    sm_config_set_in_pins(&c, PIN_GC_CLK);
    sm_config_set_in_shift(&c, true, true, 1);
    sm_config_set_fifo_join(&c, PIO_FIFO_JOIN_RX);
    sm_config_set_jmp_pin(&c, PIN_GC_CLK);

    pio_sm_init(pio, sm, offset, &c);
}

%}
